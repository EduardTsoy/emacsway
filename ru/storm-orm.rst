
.. post:: Oct 10, 2015
   :language: ru
   :tags: ORM, Storm ORM, DataMapper
   :category:
   :author: Ivan Zakrevsky


Я выбираю Storm ORM
===================

В промышленных решениях я стал использовать `KISS-style <https://en.wikipedia.org/wiki/KISS_principle>`__ `Storm ORM <https://storm.canonical.com/>`__, и здесь я попытаюсь объяснить почему.


Мои критерии к ORM
==================

\- **Скорость**. ORM должен быть быстрым.
ORM должен иметь `Identity Map <http://martinfowler.com/eaaCatalog/identityMap.html>`__ для предотвращения запросов в БД, если объект уже был загружен.
Этот момент особенно важен, когда различные изолированные компоненты приложения пытаются загрузить один и тот же объект из БД в собственную область видимости.
Кроме того, я считаю, что Identity Map должен конфигурироваться под уровни изоляции транзакции, чтобы, например, не повторять запросы в БД, если такого объекта не существует.
Хороший ORM освобождает от необходимости "обманывать" дескрипторы связей, предустанавливая в них массово предзагруженные одним запросом связанные объекты, чтобы избежать отдельных запросов на каждое обращение к внешней связи.

\- **Простота**. ORM не должен пугать своим видом в отладчике, а понять что он делает можно было не более чем из просмотра исходников. 
Любой продукт рано или поздно умирает, или хотя бы теряет интерес к себе со стороны автора, поэтому всегда нужно быть готовым взять сопровождение выбранного продукта на себя.
Новые люди должны легко осваивать продукт. А единственным источником истины о коде служит сам код. Комментарии, документирование, конечно, облегчают осваивание продукта, но часто они освещают далеко не все, и нередко отстают от реального кода.
И я не встречал в своей практике ни одной библиотеки, которую не было бы необходимости адаптировать или расширять. А в таких вопросах простота выходит на первый план.

\- **Архитектура**. Грамотное разделение уровней абстракции, соблюдение базовых принципов архитектуры, таких как `SOLID <https://en.wikipedia.org/wiki/SOLID_%28object-oriented_design%29>`__.

Если Вы не можете использовать отдельно взятый компонент ORM, например SQLBuilder, изолированно от всей системы, то, наверное, такой ORM лучше вообще не использовать (в пользу "низкоуровневых" паттернов обработки данных). Хорошо спроектированный ORM позволяет использовать свои компоненты по отдельности, SQLBuilder, Connection, DataMapper, Identity Map, `Unit of Work <http://martinfowler.com/eaaCatalog/unitOfWork.html>`__, `Repository <http://martinfowler.com/eaaCatalog/repository.html>`__. Можете ли Вы в своем ORM использовать Raw-SQL (полностью или частично)? Можете ли Вы изолированно использовать только DataMapper? Можете ли Вы подменить DataMapper, например, на `фиктивную службу <http://martinfowler.com/eaaCatalog/serviceStub.html>`__, которая не будет осуществлять запросы в БД?

Возможности любого ORM приходится расширять. Насколько легко расширить Ваш ORM без форков, патчей, манкипатчей? Соблюдается ли в нем `Open/closed principle <https://en.wikipedia.org/wiki/Open/closed_principle>`__?

    "The primary occasion for using Data Mapper is when you want the database schema and the object model to evolve independently. The most common case for this is with a Domain Model (116). Data Mapper's primary benefit is that when working on the domain model you can ignore the database, both in design and in the build and testing process. The domain objects have no idea what the database structure is, because all the correspondence is done by the mappers." (Patterns of Enterprise Application Architecture, By Martin Fowler)

\- `ACID <https://en.wikipedia.org/wiki/ACID>`__. Хорошая система следит за соответствием объекта в памяти его записи в БД. Представьте, что Вы загрузили объект, и затем сделали коммит. На этот объект уже ссылаются десятки других объектов, но он был изменен в БД другим потоком. Если после этого Вы приступите к изменению этого объекта, - изменения, внесенные другим потоком будут утрачены. В момент коммита Вам необходимо согласовать состояние объектов в памяти с данными на диске, и при этом сохранить все ссылки на них.

\- **Сокрытие источника**. Хороший ORM позволяет Вам позабыть о своем существовании, и обращаться с объектами моделей так, будто это обычные объекты. Он не будет раскрывать источник данных, требуя от Вас явного вызова метода для сохранения объектов. Не будет вынуждать Вас "перезагружать" объекты. Позволит легко подменить маппер, даже если Вы смените реляционную БД на нереляционную.

Представьте, что Вы создали два новых объекта, из которых один ссылается на другой по внешнему ключу. Можете ли Вы создать между ними связь до того, как хотя бы один из них будет сохранен в БД и получит первичный ключ? Обновится ли значение внешнего ключа связанного объекта в тот момент когда первый объект будет сохранен и получит первичный ключ?

Хороший ORM предотвращает дедлоки, потому что сохраняет все объекты непосредственно перед коммитом, минимизируя интервал времени от первого сохранения до коммита. Кроме того, он позволит Вам влиять на порядок сохранения объектов, например, используя топологическую сортировку для предотвращения дедлоков.


Другие достоинства
==================

Несмотря на номер релиза, - код достаточно стабилен. Удачная архитектура в сочетании с `принципом KISS <https://en.wikipedia.org/wiki/KISS_principle>`__ создает ложную иллюзию, что Storm ORM якобы не развивается.
Это не так. На самом деле, там просто нечего развивать.
За три года копания в исходниках Storm ORM я не нашел ничего, что можно было бы улучшить.
Расширить - да, можно. Но не изменить.
`Коммиты происходят регулярно <https://code.launchpad.net/storm>`__. Но их можно охарактеризовать как "вылизывание", или "полировка".

Storm ORM поддерживает композитные ключи и связи (после Django ORM я облегченно вздохнул).

Благодаря Identity Map, Storm ORM очень быстр.
На реальном проекте после внедрения Storm ORM (вместо Django ORM) затраты на работу ORM упали с 0.21 сек до 0.014, т.е. в 15 раз, а совокупное время генерации страницы сократилось в два раза, с 0.48 сек до 0.24 сек. Количество запросов в БД сократилось с 88 до 7.
Identity Map так же делает ненужными утилиты типа prefetch_related(), правда только для внешних ключей.

Работать с кодом Storm ORM приятно. Можно найти много интересных методик по оптимизации кода. Нужно отдать должное разработчикам Storm ORM, - они совершили настоящий умственный подвиг. Весь код тщательно продуман. Любые попытки его улучшить обычно только убеждают в правильности существующего решения.

Storm ORM очень грамотно обрабатывает транзакции. Здесь нельзя встретить бездумный реконнект в случае обрыва соединения во время незавершенной транзакции. Соединение восстановится только в том случае, если это не может отразиться на целостности данных. Сами транзакции сделаны двухуровневыми. В случае rollback откатывается так же состояние объектов в памяти.

Другие достоинства хорошо отражены в `Tutorial <https://storm.canonical.com/Tutorial>`__ и в `Manual <https://storm.canonical.com/Manual>`__


По поводу SQLAlchemy
====================

В общем-то любой ORM хорош, если он реализует принципы нашумевшей книги "Patterns of Enterprise Application Architecture", By Martin Fowler.
Storm ORM контрастирует своей простотой на фоне SQLAlchemy так же, как VIM на фоне Emacs, или jQuery на фоне Dojo.
Идеологически между ними много общего, я бы даже сказал, что Storm ORM - это упрощенная версия SQLAlchemy.
Исходники Storm ORM изучаются быстрее, нежели вводный tutorial SQLAlchemy.
Раширяется и адаптируется Storm ORM быстрее, чем приходит понимание того, как это можно сделать под SQLAlchemy.

Но существует грань, которая делает SQLAlchemy более предпочтительной, чем Storm ORM.
Если функционал Storm ORM Вас устраивает, Вы "владеете пером", и располагаете временем на адаптацию библиотеки под свои нужды, то Storm ORM выглядит привлекательней.
В противном случае, SQLAlchemy становится предпочтительней, даже невзирая на уровень ее сложности.


О недостатках
=============

В моей практике было три случая, когда в Storm ORM требовалось "допиливать" то, что SQLAlchemy (или ее сообщество) предоставляет в готовом виде.

1. `Массовая вставка объектов <http://docs.sqlalchemy.org/en/rel_1_0/orm/session_api.html?highlight=bulk_save#sqlalchemy.orm.session.Session.bulk_save_objects>`__, причем, с условием ON DUPLICATE KEY UPDATE.
2. Адаптация `SQL Builder под интерфейс Django ORM <https://github.com/mitsuhiko/sqlalchemy-django-query>`__.
3. Поддержка паттерна `Concrete Table Inheritance <http://docs.sqlalchemy.org/en/latest/orm/extensions/declarative/inheritance.html#concrete-table-inheritance>`__

В Storm ORM `нет блокировки потоков <https://bugs.launchpad.net/storm/+bug/1412845>`__ на критических операциях. Это не проблема, и легко решается. Но об этом нужно знать, иначе в условиях высоко-конкурентных потоков можно завалить прод.

Расширять функциональность Storm ORM все-таки придется. Возможности SQL-билдера нужно расширять. Утилита prefetch_related() для OneToMany() все-таки не помешает. Возможно, понадобится реализовать каскадное удаление средствами ORM, а не базы данных. И добавить сериализатор объектов.

То что класс Store (по сути паттерн Repository) совмещает в себе обязанности маппера, не очень удобно.
Например, это создает проблему в реализации паттерна `Class Table Inheritance <http://martinfowler.com/eaaCatalog/classTableInheritance.html>`__.
Сами разработчики Storm ORM советуют `заменить наследование композицией <https://storm.canonical.com/Infoheritance>`__.
Отсутствие выделенного класса для маппера вынуждает так же загромождать доменную модель `служебной логикой <https://storm.canonical.com/Manual#A__storm_pre_flush__>`__.


О неоднозначном
===============

Поддержка ACID привела к тому, что доменная модель на самом деле не является чистой.
Тем не менее, она имеет чистый интерфейс, и ведет себя как обычный чистый объект.
На самом деле инстанция модели не содержит данных, а ссылается на структуру данных посредством дескрипторов.
Реализовать все это (тем более в стиле KISS), является титаническим трудом.
Хотя я не уверен, что сама реализация такого сложного механизма соответствует принципу KISS.
Быть может, простота реализации здесь была бы предпочтительней, нежели простота интерфейса.
И тем не менее, это делает одним аргументом против ORM меньше.


FAQ
===

*q: Storm ORM не поддерживает Python3.*

a: Если Вы мигрировали хотя бы одну библиотеку на Python3, то понимаете, что этот процесс больших трудностей не вызывает.
95% работы делает команда ``2to3``. 
Единственный вопрос, который может иметь значение, - это мирация Си-расширения.
Впрочем, даже без него Storm ORM работает достаточно быстро, и не сильно теряет в производительности.
Найти Си-расширение под Python3 можно `здесь <http://bazaar.launchpad.net/~martin-v/storm/storm3k/view/head:/storm/cextensions.c>`__ (`diff <http://bazaar.launchpad.net/~martin-v/storm/storm3k/revision/438>`__)


*q: Как использовать Storm ORM с фрагментами RAW-SQL*

a: Вообще-то так лучше не делать. Лучше расширить SQL-builder. Но если очень надо::

    >>> from storm.expr import SQL
    >>> from authors.models import Author
    >>> store = get_my_store()
    >>> list(store.find(Author, SQL("auth_user.id = %s", (1,), Author)))
    [<authors.models.Author object at 0x7fcd64cea750>]


*q: Как использовать Storm ORM с полностью чистым SQL, чтобы результат запроса содержал инстанции моделей?*

a: Поскольку Шторм использует паттерны Data Mapper, Identity Map и Unit of Work, мы должны указать в выборке все поля модели, и использовать для загрузки метод ``Store._load_object()``::

    >>> store = get_my_store()
    >>> from storm.info import get_cls_info
    >>> from authors.models import Author

    >>> author_info = get_cls_info(Author)

    >>> # Load single object
    >>> result = store.execute("SELECT " + store._connection.compile(author_info.columns) + " FROM author where id = %s", (1,))
    >>> store._load_object(author_info, result, result.get_one())
    <authors.models.Author at 0x7fcc76a85090>

    >>> # Load collection of objects
    >>> result = store.execute("SELECT " + store._connection.compile(author_info.columns) + " FROM author where id IN (%s, %s)", (1, 2))
    >>> [store._load_object(author_info, result, row) for row in result.get_all()]
    [<authors.models.Author at 0x7fcc76a85090>,
     <authors.models.Author at 0x7fcc76a854d0>]
