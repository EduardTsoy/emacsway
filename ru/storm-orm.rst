
.. post::
   :tags:
   :category:


Storm ORM
=========

В промышленных решениях я все чаще стал использовать `Storm ORM <https://storm.canonical.com/>`__, и как мне кажется, небезосновательно.

Основные критерии которые я предъявляю к ОРМ:

\- **Скорость**. ОРМ должен быть быстрым.
ОРМ должен иметь `Identity Map <http://martinfowler.com/eaaCatalog/identityMap.html>`__ для предотвращения запросов в БД, если объект уже был загружен.
Этот момент особенно важен, когда различные изолированные компоненты приложения пытаются загрузить один и тот же объект из БД в собственную область видимости.
Кроме того, я считаю, что Identity Map должен конфигурироваться под уровни изоляции транзакции, чтобы, например, не повторять запросов в БД, если такого объекта не существует.
Хороший ОРМ освобождает от необходимости "обманывать" дескрипторы связей, предустанавливая в них предзагруженные одним запросом связанные объекты, чтобы избежать отдельных запросов на каждое обращение к внешней связи.

\- **Простота**. ОРМ не должен пугать своим видом в отладчике, а понять что он делает можно было не более чем из просмотра исходников. 
Любой продукт рано или поздно умирает, и всегда нужно быть готовым взять его сопровождение на себя.
Новые люди должны легко осваивать продукт. А единственным источником истины о коде служит сам код. Комментарии, документирование, конечно, облегчают осваивание продукта, но часто они освещают далеко не все, и нередко отстают от реального кода.
И я не встречал в своей практике ни одной библиотеки, которую не было бы необходимости адаптировать или расширять. В таких вопросах простота выходит на первый план.

\- **Архитектура**. Грамотное разделение уровней абстракции, соблюдение базовых принципов архитектуры, таких как `SOLID <https://en.wikipedia.org/wiki/SOLID_%28object-oriented_design%29>`__.

Если Вы не можете использовать компонент ОРМ, например SQLBuilder, отдельно от всей системы, то, наверное, лучше такой ОРМ вообще не использовать (в пользу "низкоуровневых" паттернов обработки данных). Хорошо спроектированный ОРМ позволяет использовать свои компоненты по отдельности, SQLBuilder, коннектор, маппер, Identity Map, `Unit of Work <http://martinfowler.com/eaaCatalog/unitOfWork.html>`__, `Repository <http://martinfowler.com/eaaCatalog/repository.html>`__. Можете ли Вы в своем ОРМ использовать Raw-SQL (полностью или частично)? Можете ли Вы изолированно использовать только маппер? Можете ли Вы подменить маппер, например, на `фиктивную службу <http://martinfowler.com/eaaCatalog/serviceStub.html>`__, которая не будет осуществлять запросы в БД?

Возможности любого ОРМ приходится расширять. Насколько легко расширить Ваш ОРМ без форков, патчей, манкипатчей? Соблюдается ли в нем принцип `Open/closed principle <https://en.wikipedia.org/wiki/Open/closed_principle>`__?

    "As the domain logic gets feisty, you want to be able to test it without having to talk to the database all the time."

    "The whole layer of Data Mapper can be substituted, either for testing purposes or to allow a single domain layer to work with different databases."

    "The primary occasion for using Data Mapper is when you want the database schema and the object model to evolve independently. The most common case for this is with a Domain Model (116). Data Mapper's primary benefit is that when working on the domain model you can ignore the database, both in design and in the build and testing process. The domain objects have no idea what the database structure is, because all the correspondence is done by the mappers."

    "A good example of this is in testing domain objects, where the tests run much faster without database writes."

    "Patterns of Enterprise Application Architecture", By Martin Fowler

\- `ACID <https://en.wikipedia.org/wiki/ACID>`__. Хорошая система следит за соответствием объекта в памяти его записи в БД. Представьте, что Вы загрузили объект, и затем сделали коммит. На этот объект уже ссылаются десятки других объектов, но он был изменен в БД другим потоком. Если после этого Вы приступите к изменению этого объекта, - изменения, внесенные другим потоком будут утрачены. В момент коммита Вам необходимо согласовать состояние объектов в памяти с данными на диске, и при этом сохранить все ссылки на них.

По правде говоря, реализация принципов ACID столь сложна, что лично я отдаю здесь предпочтение простоте реализации, нежели простоте интерфейса. И если бы Шторм их не реализовывал, я бы не сильно огорчился.

\- **Сокрытие источника**. Хороший ОРМ позволяет Вам позабыть о своем существовании, и обращаться с объектами моделей так, будто это обычные объекты. Он не будет раскрывать источник данных, требуя от Вас явного вызова метода для сохранения объектов. Не будет вынуждать Вас "перезагружать" объекты. Позволит легко подменить маппер, даже если Вы смените реляционную БД на нереляционную.

Представьте, что Вы создали два новых объекта, из которых один ссылается на другой по внешнему ключу. Можете ли Вы создать между ними связь до того, как хотя бы один из них будет сохранен в БД и получит первичный ключ? Обновится ли значение внешнего ключа связанного объекта в тот момент когда первый объект будет сохранен и получит первичный ключ?

Хороший ОРМ предотвращает дедлоки, потому что сохраняет все объекты непосредственно перед коммитом, минимизируя интервал времени от первого сохранения до коммита. Кроме того, он позволит Вам влиять на порядок сохранения объектов, например, используя топологическую сортировку для предостращения дедлоков.
