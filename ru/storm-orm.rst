
.. post:: Oct 10, 2015
   :language: ru
   :tags: ORM, Storm ORM, DataMapper
   :category:
   :author: Ivan Zakrevsky


Почему я выбираю Storm ORM
==========================

В промышленных решениях я чаще стал использовать `KISS-style <https://en.wikipedia.org/wiki/KISS_principle>`__ `Storm ORM <https://storm.canonical.com/>`__, и здесь я попытаюсь объяснить почему.

.. contents:: Содержание


Мои критерии к ORM
==================

\- **Скорость**. ORM должен быть быстрым.
ORM должен иметь `Identity Map <http://martinfowler.com/eaaCatalog/identityMap.html>`__ для предотвращения запросов в БД, если объект уже был загружен.
Этот момент особенно важен, когда различные изолированные компоненты приложения пытаются загрузить один и тот же объект из БД в собственную область видимости.
Кроме того, я считаю, что Identity Map должен конфигурироваться под уровни изоляции транзакции, чтобы, например, не повторять запросы в БД, если такого объекта не существует.

\- **Простота**. ORM не должен пугать своим видом в отладчике, а понять что он делает можно было не более чем из просмотра исходников. 
Любой продукт рано или поздно умирает, или хотя бы теряет интерес к себе со стороны автора, поэтому всегда нужно быть готовым взять сопровождение выбранного продукта на себя.
Новые люди должны легко осваивать продукт. А единственным источником истины о коде служит сам код. Комментарии, документирование, конечно, облегчают осваивание продукта, но часто они освещают далеко не все, и нередко отстают от реального кода.
И я не встречал в своей практике ни одной библиотеки, которую не было бы необходимости адаптировать или расширять. А в таких вопросах простота выходит на первый план.

\- **Архитектура**. Грамотное разделение уровней абстракции, соблюдение базовых принципов архитектуры, таких как `SOLID <https://en.wikipedia.org/wiki/SOLID_%28object-oriented_design%29>`__.

Если Вы не можете использовать отдельно взятый компонент ORM, например SQLBuilder, изолированно от всей системы, то, наверное, такой ORM лучше вообще не использовать (в пользу "низкоуровневых" паттернов обработки данных). Хорошо спроектированный ORM позволяет использовать свои компоненты по отдельности, `Query Object <http://martinfowler.com/eaaCatalog/queryObject.html>`__ (SQLBuilder), Connection, `DataMapper <http://martinfowler.com/eaaCatalog/dataMapper.html>`__, `Identity Map <http://martinfowler.com/eaaCatalog/identityMap.html>`__, `Unit of Work <http://martinfowler.com/eaaCatalog/unitOfWork.html>`__, `Repository <http://martinfowler.com/eaaCatalog/repository.html>`__. Можете ли Вы в своем ORM использовать Raw-SQL (полностью или частично)? Можете ли Вы изолированно использовать только DataMapper? Можете ли Вы подменить DataMapper, например, на `фиктивную службу <http://martinfowler.com/eaaCatalog/serviceStub.html>`__, которая не будет осуществлять запросы в БД?

Возможности любого ORM приходится расширять. Насколько легко расширить Ваш ORM без форков, патчей, манкипатчей? Соблюдается ли в нем `Open/closed principle <https://en.wikipedia.org/wiki/Open/closed_principle>`__?

    "The primary occasion for using Data Mapper is when you want the database schema and the object model to evolve independently. The most common case for this is with a Domain Model (116). Data Mapper's primary benefit is that when working on the domain model you can ignore the database, both in design and in the build and testing process. The domain objects have no idea what the database structure is, because all the correspondence is done by the mappers." (Patterns of Enterprise Application Architecture, By Martin Fowler)

\- `ACID <https://en.wikipedia.org/wiki/ACID>`__. Хорошая система следит за соответствием объекта в памяти его записи в БД. Представьте, что Вы загрузили объект, и затем сделали коммит. На этот объект уже ссылаются десятки других объектов, но он был изменен в БД другим потоком. Если после этого Вы приступите к изменению этого объекта, - то изменения, внесенные другим потоком будут утрачены. В момент коммита Вам необходимо согласовать состояние объектов в памяти с данными на диске, и при этом сохранить все ссылки на них.

\- **Сокрытие источника**. Хороший ORM позволяет Вам позабыть о своем существовании, и обращаться с объектами моделей так, будто это обычные объекты. Он не будет раскрывать источник данных, требуя от Вас явного вызова метода для сохранения объектов. Не будет вынуждать Вас "перезагружать" объекты. Позволит легко подменить маппер, даже если Вы смените реляционную БД на нереляционную.

Представьте, что Вы создали два новых объекта, из которых один ссылается на другой по внешнему ключу. Можете ли Вы создать между ними связь до того, как хотя бы один из них будет сохранен в БД и получит первичный ключ? Обновится ли значение внешнего ключа связанного объекта в тот момент когда первый объект будет сохранен и получит первичный ключ?

Хороший ORM предотвращает дедлоки, потому что сохраняет все объекты непосредственно перед коммитом, минимизируя интервал времени от первого сохранения до коммита. Кроме того, он позволит Вам влиять на порядок сохранения объектов, например, используя топологическую сортировку для предотвращения дедлоков.


О достоинствах
==============

Несмотря на номер релиза, - код достаточно стабилен. Удачная архитектура в сочетании с `принципом KISS <https://en.wikipedia.org/wiki/KISS_principle>`__ создает ложную иллюзию, что Storm ORM якобы не развивается.
Это не так. На самом деле, там просто нечего развивать.
За три года копания в исходниках Storm ORM я не нашел ничего, что можно было бы улучшить.
Расширить - да, можно. Но не изменить.
`Коммиты происходят регулярно <https://code.launchpad.net/storm>`__. Но их можно охарактеризовать как "вылизывание", или "полировка".

Storm ORM поддерживает композитные ключи и связи (после Django ORM я облегченно вздохнул).

Благодаря Identity Map, Storm ORM очень быстр.
На странице одного из проектов, после внедрения Storm ORM (вместо Django ORM), затраты на работу ORM упали с 0.21 сек до 0.014 сек, т.е. в 15 раз, а совокупное время генерации страницы сократилось в два раза, с 0.48 сек до 0.24 сек.
Количество запросов в БД сократилось с 88 до 7.
Identity Map так же делает ненужными утилиты типа prefetch_related(), правда только для внешних ключей ссылающихся на первичный ключ.

Работать с кодом Storm ORM приятно. Можно найти много интересных методик по оптимизации кода. Нужно отдать должное разработчикам Storm ORM, - они совершили настоящий умственный подвиг. Весь код тщательно продуман. Любые попытки его улучшить обычно только убеждают в правильности существующего решения.

Storm ORM очень грамотно обрабатывает транзакции. Здесь нельзя встретить бездумный реконнект в случае обрыва соединения во время незавершенной транзакции. Соединение восстановится только в том случае, если это не может отразиться на целостности данных. Сами транзакции сделаны двухуровневыми. В случае rollback откатывается так же состояние объектов в памяти.

Благодаря наличию у Storm ORM возможности скомпилировать критерии выборки в коллекцию фильтров Python-кода, применимых к любой коллекции объектов в памяти, Storm ORM предоставляет неплохие возможности для создания фиктивного маппера для тестов.
А для выборки объектов из ``Store()`` по первичному ключу (в том числе и посредством вызова Foreign Key), и создавать вообще ничего не нужно, так как благодаря паттерну Identity Map можно просто не посылать объекты в БД, и использовать реальный маппер как фиктивный.

Storm ORM не производит конвертации значений сразу, в момент загрузки объекта. Вместо этого он просто заворачивает значение во враппер (адаптер) - класс Variable.
С одной стороны, это оптимизирует ресурсы и повышает производительность.
С другой - позволяет правильно представлять значение в зависимости от контекста использования (Python или DB).
Здесь, правда, тоже есть некоторые нюансы.

Например, мы добавляем критерий выборки::

    (GeoObjectModel.point == author_instance.location)

Конвертор какого атрибута здесь должен работать, ``GeoObjectModel.point`` или ``AuthorModel.location``?
Очевидно что ``AuthorModel.location``, так как именно он предоставляет значение. Но работать будет ``GeoObjectModel.point``.
Что если эти конверторы имеют различное поведение?
И что произойдет если мы передадим такой критерий: ``Func('SOME_FUNCTION_NAME', AuthorModel.location)``?

Справедливости ради нужно сказать, что Storm ORM сделал большой прорыв по упорядочиванию данного аспекта, по сравнению большинством других ORM, и заложил правильный фундамент для построения идеальной конвертации.
При соблюдении несложных правил конверторы будут работать идеально правильно (для этого в критерии выборки нужно передавать `инстанцию Variable() <http://bazaar.launchpad.net/~storm/storm/trunk/view/477/storm/store.py#L597>`__, т.е. "завернутое" значение).
В то время как во многих других ORM такая возможность технически отсутствует из-за того, что конвертации делаются в момент создания объекта.
Иными словами, там конверторы фактически привязываются к типу значения а не к конкретному атрибуту (как это декларируется), что делает их практически бесполезными, учитывая что эти функции итак `возложены на коннектор <http://initd.org/psycopg/docs/advanced.html#adapting-new-python-types-to-sql-syntax>`__.

Другие достоинства хорошо отражены в `Tutorial <https://storm.canonical.com/Tutorial>`__ и в `Manual <https://storm.canonical.com/Manual>`__


По поводу SQLAlchemy
====================

В общем-то любой ORM хорош, если он реализует принципы нашумевшей книги "Patterns of Enterprise Application Architecture", By Martin Fowler.
Storm ORM контрастирует своей простотой на фоне SQLAlchemy так же, как VIM на фоне Emacs, или jQuery на фоне Dojo.
Идеологически между ними много общего, я бы даже сказал, что Storm ORM - это упрощенная версия SQLAlchemy.
Исходники Storm ORM изучаются быстрее, нежели вводный tutorial SQLAlchemy.
Раширяется и адаптируется Storm ORM быстрее, чем приходит понимание того, как это можно сделать под SQLAlchemy.

Но существует грань, которая делает SQLAlchemy более предпочтительной, чем Storm ORM.
Если функционал Storm ORM Вас устраивает, Вы "владеете пером", и располагаете временем на адаптацию библиотеки под свои нужды, то Storm ORM выглядит привлекательней.
В противном случае, SQLAlchemy становится предпочтительней, даже невзирая на уровень ее сложности, поскольку многие решения предоставляет "из коробки".


О недостатках
=============

В моей практике было три случая, когда в Storm ORM требовалось "допиливать" то, что SQLAlchemy (или ее сообщество) предоставляет в готовом виде.

1. `Массовая вставка объектов <http://docs.sqlalchemy.org/en/rel_1_1/orm/session_api.html#sqlalchemy.orm.session.Session.bulk_save_objects>`__, причем, с условием ON DUPLICATE KEY UPDATE.
2. Адаптация `SQL Builder под интерфейс Django ORM <https://github.com/mitsuhiko/sqlalchemy-django-query>`__.
3. Поддержка паттерна `Concrete Table Inheritance <http://docs.sqlalchemy.org/en/rel_1_1/orm/extensions/declarative/inheritance.html#concrete-table-inheritance>`__

В Storm ORM `нет блокировки потоков <https://bugs.launchpad.net/storm/+bug/1412845>`__ при ленивой модификации критически важных глобальных метаданных. Это не проблема, и легко решается (достаточно исполнить их сразу, под блокировкой). Но об этом нужно знать, иначе в условиях высоко-конкурентных потоков можно завалить прод.

Расширять функциональность Storm ORM все-таки придется. Возможности SQL-билдера нужно расширять. Утилита prefetch_related() для OneToMany() тоже не помешала бы. Возможно, понадобится реализовать каскадное удаление средствами ORM, а не базы данных. И добавить сериализатор объектов.

То что класс Store (по сути паттерн Repository) совмещает в себе обязанности маппера, не очень удобно.
Например, это создает проблему в реализации паттерна `Class Table Inheritance <http://martinfowler.com/eaaCatalog/classTableInheritance.html>`__.
Сами разработчики Storm ORM советуют `заменить наследование композицией <https://storm.canonical.com/Infoheritance>`__.
Отсутствие выделенного класса для маппера вынуждает так же загромождать доменную модель `служебной логикой <https://storm.canonical.com/Manual#A__storm_pre_flush__>`__.

.. Дескрипторы связей Storm ORM запращивают store у объекта. Таким образом, если объект приаттачен к фиктивному стору, то и связи он будет искать в фиктивном сторе. Таким образом, дескрипторы не представляют никаких проблем для подмены реального стора на фиктивный.

.. По этим причинам мне захотелось сделать `ascetic ORM <https://bitbucket.org/emacsway/ascetic>`__ который был бы еще проще (который, впрочем, на сегодня является не более чем сборищем незавершенных мыслей).


О неоднозначном
===============

Поддержка ACID привела к тому, что доменная модель на самом деле не является чистой.
Тем не менее, она имеет чистый интерфейс, и ведет себя как обычный чистый объект.
На самом деле инстанция модели не содержит данных, а ссылается на структуру данных посредством дескрипторов.
Реализовать все это (тем более в стиле KISS), является титаническим трудом.
Хотя я не уверен, что сама реализация такого сложного механизма соответствует принципу KISS.
Быть может, простота реализации здесь была бы предпочтительней, нежели простота интерфейса.
И тем не менее, это делает одним аргументом против ORM меньше.


FAQ
===

*q: Storm ORM не поддерживает Python3.*

a: Если Вы мигрировали хотя бы одну библиотеку на Python3, то понимаете, что этот процесс больших трудностей не вызывает.
95% работы делает команда ``2to3``. 
Единственный вопрос, который может иметь значение, - это мирация Си-расширения.
Впрочем, даже без него Storm ORM работает достаточно быстро, и не сильно теряет в производительности.
Найти Си-расширение под Python3 можно `здесь <http://bazaar.launchpad.net/~martin-v/storm/storm3k/view/head:/storm/cextensions.c>`__ (`diff <http://bazaar.launchpad.net/~martin-v/storm/storm3k/revision/438>`__)


*q: Как использовать Storm ORM с фрагментами Raw-SQL*

a: Вообще-то так лучше не делать. Лучше расширить SQL-builder. Но если очень надо::

    >>> from storm.expr import SQL
    >>> from authors.models import Author
    >>> store = get_my_store()
    >>> list(store.find(Author, SQL("auth_user.id = %s", (1,), Author)))
    [<authors.models.Author object at 0x7fcd64cea750>]


*q: Как использовать Storm ORM с полностью чистым SQL, чтобы результат запроса содержал инстанции моделей?*

a: Поскольку Storm ORM использует паттерны Data Mapper, Identity Map и Unit of Work, мы должны указать в выборке все поля модели, и использовать для загрузки метод ``Store._load_object()``::

    >>> store = get_my_store()
    >>> from storm.info import get_cls_info
    >>> from authors.models import Author

    >>> author_info = get_cls_info(Author)

    >>> # Load single object
    >>> result = store.execute("SELECT " + store._connection.compile(author_info.columns) + " FROM author where id = %s", (1,))
    >>> store._load_object(author_info, result, result.get_one())
    <authors.models.Author at 0x7fcc76a85090>

    >>> # Load collection of objects
    >>> result = store.execute("SELECT " + store._connection.compile(author_info.columns) + " FROM author where id IN (%s, %s)", (1, 2))
    >>> [store._load_object(author_info, result, row) for row in result.get_all()]
    [<authors.models.Author at 0x7fcc76a85090>,
     <authors.models.Author at 0x7fcc76a854d0>]


А нужен ли вообще ORM?
======================

Честно говоря, нет необходимости использовать ОРМ всегда и везде. Во многих случаях (например, если от приложения требуется просто выдать список JSON значений) вполне достаточно простейшего `Table Data Gateway <http://martinfowler.com/eaaCatalog/tableDataGateway.html>`__, который будет возвращать простейшие значения `Data Transfer Object <http://martinfowler.com/eaaCatalog/dataTransferObject.html>`__. Тут уже дело личных предпочтений.


Нужен ли Query Object?
----------------------

Единственное в чем я убежден твердо, - это в том, что без паттерна `Query Object <http://martinfowler.com/eaaCatalog/queryObject.html>`__ (часто именуемом как SQLBuilder) обойтись довольно трудно, если не невозможно.

**Во-первых**, даже самые стойкие сторонники концепции "чистого SQL" достаточно быстро сталкиваются с невозможностью выразить SQL-запрос в чистом виде, и вынуждены его динамически составлять в зависимости от условий.
А это уже разновидность концепции SQLBuilder, пусть и в примитивном виде, и реализованном в частном порядке.
А решения частного порядка всегда занимают много места, так как отступают от принципа `DRY <https://en.wikipedia.org/wiki/Don't_repeat_yourself>`__.

Проиллюстрирую это примером. Имеем запрос на выборку объявлений из БД по 5-ти критериям.
Нужно позволить пользователям выбирать объявления по совокупности любого количества из перечисленных критериев:

0. Без критериев.
1. Типу объявления.
2. Стране, области, городу.
3. По категориям, включая вложеннные категории.
4. По пользователям (все объявления одного пользователя)
5. По поисковым словам.

Итого, пришлось бы заготовить 2^5 = 32 фиксированных SQL-запроса, и это если не учитывать вложенностей древовидных структур (иначе п.3 пришлось бы разнести на еще 3 пункта, так как нередко эти данные хранятся денормализованно).

Список возможных комбинаций критериев::

    0
    1
    1,2
    1,2,3
    1,2,3,4
    1,2,3,4,5
    1,2,4
    1,2,4,5
    1,2,5
    1,3
    1,3,4
    1,3,4,5
    1,3,5
    1,4
    1,4,5
    1,5
    2,
    2,3
    2,3,4
    2,3,4,5
    2,3,5
    2,4
    2,4,5
    2,5
    3
    3,4
    3,4,5
    3,5
    4
    4,5
    5

А если добавить еще один критерий, - это будет 2^6=64 комбинации, т.е. в 2 раза больше. Еще один, - это будет 2^7=128 комбинаций.

Так же в качестве примера можно привести реализацию следующих паттернов и подходов:

- Динамически изменяемая сортировка
- Мультиязычность посредством суффиксирования полей
- `Concrete Table Inheritance <http://martinfowler.com/eaaCatalog/concreteTableInheritance.html>`__
- `Class Table Inheritance <http://martinfowler.com/eaaCatalog/classTableInheritance.html>`__
- `Entity–attribute–value <https://en.wikipedia.org/wiki/Entity%E2%80%93attribute%E2%80%93value_model>`__
- и т.д.

**Во-вторых**, такие запросы невозможно наследовать без `синтаксического анализа <https://pypi.python.org/pypi/sqlparse>`__ (например, чтобы просто изменить сортировку), что обычно влечет за собой их полное копирование.
А каждую копию приходится сопровождать отдельно, что усложняет сопровождение такого кода.
Впрочем, на досуге я написал простейший `mini-builder, который представляет SQL-запрос в виде многоуровневого списка с фрагментами Raw-SQL <https://bitbucket.org/emacsway/sqlbuilder/src/default/sqlbuilder/mini/tests.py>`__, что позволяет полноценно выстраивать условно-составные SQL-запросы и при этом практически полностью сохраняет читаемость Raw-SQL.

**В-третьих**,  мне нередко приходилось видеть среди файлов с Raw-SQL диффы на несколько сотен строк только потому, что в модель был добавлен новый атрибут.
В случае использования SQLBuilder таких проблем не возникает.
Так же как и не возникает необходимости изменять интерфейсы для методов выборки, поскольку все критерии выборки инкапсулированы в единственный объект.

**В-четвертых**, если какое-то значение объекта требует особой конвертации в DB представление, - нам придется загромождать код явным вызовом этих конвертаций.


Нужен ли сам DataMapper?
------------------------

Что же касается самого маппера, то тут следует решить, нужна ли приложению `Domain Model <http://martinfowler.com/eaaCatalog/domainModel.html>`__, или вполне устроит паттерн `Transaction Script <http://martinfowler.com/eaaCatalog/transactionScript.html>`__.
Я не буду останавливаться на этом выборе, так как он хорошо освещен в "Patterns of Enterprise Application Architecture", By Martin Fowler.
Но если нуждам приложения больше соответствует Domain Model, то без полноценного ORM (пусть и самодельного) обойтись будет непросто, по крайней мере, для качественной, удобной и быстрой работы.

По поводу распространенных аргументов против ORM.
Я не буду затрагивать уже пронафталиненные темы вроде того, что базы данных не поддерживают наследования.
Во-первых, наследование можно заменить композицией. Сами языки программирования реализуют наследование посредством композиции.
Во-вторых, сегодня только ленивый не знает о паттернах
`Single Table Inheritance <http://martinfowler.com/eaaCatalog/singleTableInheritance.html>`__,
`Concrete Table Inheritance <http://martinfowler.com/eaaCatalog/concreteTableInheritance.html>`__,
`Class Table Inheritance <http://martinfowler.com/eaaCatalog/classTableInheritance.html>`__ и
`Entity–attribute–value <https://en.wikipedia.org/wiki/Entity%E2%80%93attribute%E2%80%93value_model>`__.

Поэтому я затрону только два существенных на мой взгляд вопроса:

1. Представлять данные в памяти объектами, или структурами данных?
2. ACID, согласованность объекта в памяти и его данными на диске.

По поводу первого вопроса у меня нет однозначного мнения.
Мы живем в мире объектов, и именно поэтому появилось объектно-ориентированное программирование.
Человеку проще мыслить объектами. В Python даже элементарные типы являются полноценными объектами, с методами, наследованием и т.п.

В чем отличие между структурой данных и объектом? В Python это отличие сугубо условное. Объекты используют представление данных на абстрактном уровне.

    "Объекты скрывают свои данные за абстракциями и предоставляют функции, работающие с этими данными. Структуры данных раскрывают свои данные и не имеют осмысленных функций." ("Clean Code" by C.Martin)

Тут мы снова упираемся в вопрос Domain Model vs Transaction Script, поскольку доменная модель по своему определению охватывает поведение (функции) и свойства (данные).

Но есть еще один немаловажный момент. Допустим, мы храним в БД две колонки - цена и валюта. Или, например, данные полиморфной связи - тип объекта и его идентификатор. Или координаты - x и y. Или путь древовидной структуры - страна, область, город, улица.
Т.е. несколько данных образуют единую сущность, и изменение части этих данных не имеет никакого смысла.
Как задать политику доступа данных и гарантировать атомарность их изменения (кроме как использованием объектов или неизменяемых типов)?

Я думаю, что мы должны думать прежде всего о бизнес-задачах. О том, какими объектами и как должна оперировать программа. Вопросы реализации не должны диктовать бизнес-логику. Вопросы хранения информации должны удовлетворять нашим требованиям, а не указывать нам требования. Если бы это было не так, то объектно-ориентированное программирование до сих пор не возникло бы.

Принцип единой обязанности гласит, что каждый объект должен иметь одну обязанность и эта обязанность должна быть полностью инкапсулирована в класс. Лишая объект поведения, мы возлагаем его поведение на другой объект, который должен обслуживать первый. Вопрос в том, оправдано ли это? Если в разделении ActiveRecord на DataMapper и DomainModel это очевидно, и направлено именно на соблюдение принципа единой обязанности, то в данном случае ответ не так очевиден. Рассуждения M.Fowler по этому поводу в статье `AnemicDomainModel <http://www.martinfowler.com/bliki/AnemicDomainModel.html>`__.

По поводу второго вопроса. Из всех ORM, что я встречал в своей практике (не только на Python), поддержка ACID в Storm ORM и SQLAlchemy реализована наилучшим образом. Надо сказать, в подавляющем большинстве существующих ORM такие попытки даже не предпринимаются.

Рассуждения M.Fowler на этот счет в статье `OrmHate <http://martinfowler.com/bliki/OrmHate.html>`__.
