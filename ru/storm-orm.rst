
.. post::
   :tags:
   :category:


Storm ORM
=========

В промышленных решениях я все чаще стал использовать `Storm ORM <https://storm.canonical.com/>`__, и как мне кажется, небезосновательно.

Основные критерии которые я предъявляю к ОРМ:

\- **Скорость**. ОРМ должен быть быстрым.
ОРМ должен иметь `Identity Map <http://martinfowler.com/eaaCatalog/identityMap.html>`__ для предотвращения запросов в БД, если объект уже был загружен.
Этот момент особенно важен, когда различные изолированные компоненты приложения пытаются загрузить один и тот же объект из БД в собственную область видимости.
Кроме того, я считаю, что Identity Map должен конфигурироваться под уровни изоляции транзакции, чтобы, например, не повторять запросов в БД, если такого объекта не существует.
Приходилось ли Вам заниматься оптимизациями, чтобы предзагружать одним запросом все связанные объекты, устраняя одиночные запросы для каждого обращения по внешней связи? Приходилось ли Вам вручную "связывать" предзагруженные объекты, чтобы дескриптор внешней связи не лез в БД?

\- **Простота**. ОРМ не должен пугать своим видом в отладчике, а понять что он делает можно было не более чем из просмотра исходников. 
Любой продукт рано или поздно умирает, и всегда нужно быть готовым взять его сопровождение на себя.
Новые люди должны легко осваивать продукт. А единственным источником истины о коде служит сам код. Комментарии, документирование, конечно, облегчают осваивание продукта, но часто они освещают далеко не все, и нередко отстают от реального кода.
И я не встречал в своей практике ни одной библиотеки, которую не было бы необходимости адаптировать или расширять. В таких вопросах простота выходит на первый план.

\- **Архитектура**. Грамотное разделение уровней абстракции, соблюдение базовых принципов архитектуры, таких как `SOLID <https://en.wikipedia.org/wiki/SOLID_%28object-oriented_design%29>`__.

Если Вы не можете использовать компонент ОРМ, например SQLBuilder, отдельно от всей системы, то, наверное, лучше такой ОРМ вообще не использовать (в пользу "низкоуровневых" паттернов обработки данных). Хорошо спроектированный ОРМ позволяет использовать свои компоненты по отдельности, SQLBuilder, коннектор, маппер, Identity Map, `Unit of Work <http://martinfowler.com/eaaCatalog/unitOfWork.html>`__, `Repository <http://martinfowler.com/eaaCatalog/repository.html>`__. Можете ли Вы в своем ОРМ использовать Raw-SQL полностью или частично? Можете ли Вы изолированно использовать только маппер? Можете ли Вы подменить маппер, например, на `фиктивную службу <http://martinfowler.com/eaaCatalog/serviceStub.html>`__, которая не будет осуществлять запросы в БД?

Возможности любого ОРМ приходится расширять. Насколько легко расширить Ваш ОРМ без форков, патчей, манкипатчей? Соблюдается ли в нем принцип `Open/closed principle <https://en.wikipedia.org/wiki/Open/closed_principle>`__?

    "As the domain logic gets feisty, you want to be able to test it without having to talk to the database all the time."

    "The whole layer of Data Mapper can be substituted, either for testing purposes or to allow a single domain layer to work with different databases."

    "The primary occasion for using Data Mapper is when you want the database schema and the object model to evolve independently. The most common case for this is with a Domain Model (116). Data Mapper's primary benefit is that when working on the domain model you can ignore the database, both in design and in the build and testing process. The domain objects have no idea what the database structure is, because all the correspondence is done by the mappers."

    "A good example of this is in testing domain objects, where the tests run much faster without database writes."

    "Patterns of Enterprise Application Architecture", By Martin Fowler

\- `ACID <https://en.wikipedia.org/wiki/ACID>`__. Обеспечивает ли Ваша система соответствие объекта в памяти и его записи в БД? Представьте, что Вы сделали коммит. Загруженый перед этим объект, на который ссылаются десятки других объектов, уже был изменен в БД другим потоком. Если после этого Вы приступите к изменению этого объекта, - изменения, внесенные другим потоком будут утрачены. В момент коммита Вам необходимо согласовать объекты в памяти с данными на диске, и при этом сохранить все ссылки на них.

По правде говоря, реализация принципов ACID столь сложна, что лично я отдаю здесь предпочтение простоте реализации, нежели простоте интерфейса. И если бы Шторм их не реализовывал, я бы не огорчился.

\- **Сокрытие источника**. Можете ли вы работать с объектами модели так, будто это обычные объекты? Нужно ли Вам явно вызывать метод сохранения объекта, раскрывая их источник, или система сама позаботится об этом? Приходилось ли Вам вручную "перезагружать" объект? Обеспечивает ли Ваш Repository сокрытие источника, чтобы Вы смогли, например, подменить маппер реляционной БД на nonrel-маппер?

Представьте, что Вы создали два новых объекта, из которых один ссылается на другой по внешнему ключу. Можете ли Вы создать между ними связь до того, как хотя бы один из них будет сохранен в БД и получит первичный ключ? Обновится ли значение внешнего ключа связанного объекта в тот момент когда объект будет сохранен и получит первичный ключ?

Приходилось ли вам разрешать проблему дедлоков? Приходилось ли Вам сталкиваться со сложностями возникающими из-за того, что между сохранением объекта и коммитом проходит слишком много времени?
