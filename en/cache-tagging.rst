
About problems of cache invalidation. Cache tagging.
===============================================


.. post::
   :language: en
   :tags: cache
   :category:
   :author: Ivan Zakrevsky

About my experience of solving problems in cache invalidation, and about principles of the library `cache-tagging`_.

.. contents:: Contents


The problem of cache dependencies
=================================

When you edit the data of some model, you must also remove all dependent caches, that contains the data of this model.
For example, when you edit instance of Product model, which presents on the cached main page of firm, you have to invalidate this cache too.
Another case, - if the data (for example, last_name) of User model has been updated, you have to invalidate all caches of user's posts, contained the last_name.

Usually, the pattern `Observer`_ (or its variety, pattern Multicast) is responsible for cache invalidation.
This means, the event handler should be aware of all dependent components, that violates encapsulation.

And then cache tagging (i.e. marking cache by tags) comes to the rescue.
For example, main page can be marked by tag ``product.id:635``.
All user's posts can be marked by tag ``user.id:10``.
Post lists can be marked by composite tag, composed of selection criteria, for example ``type.id:1;category.id:15;region.id:239``.

Now it's enough to invalidate the tag, in order to invalidate all dependent caches.
This aproach is not new, and widely used in other programming languages.
At one time it was even implemented in memcache, see `memcached-tag <http://code.google.com/p/memcached-tag/>`_.

See also:

- `Cache dependency in wheezy.caching <https://pypi.python.org/pypi/wheezy.caching>`_
- `TaggableInterface of ZF <http://framework.zend.com/manual/current/en/modules/zend.cache.storage.adapter.html#the-taggableinterface>`_
- `TagDependency of YII framework <http://www.yiiframework.com/doc-2.0/yii-caching-tagdependency.html>`_
- `Dklab_Cache: правильное кэширование — тэги в memcached, namespaces, статистика <http://dklab.ru/lib/Dklab_Cache/>`_


Should overhead be at cache reading, or at cache creation?
==========================================================

Возникает вопрос реализации инвалидации зависимых от метки кэшей.
Возможны два варианта:

\1. При инвалидации метки физически уничтожать все зависимые кэши.
Для реализации такого подхода потребуются накладные расходы при создании кэша, чтобы добавить информацию о нем в список (точнее, множество) зависимостей каждой метки (например, используя `SADD <http://redis.io/commands/sadd>`_).
Недостаток заключается в том, что инвалидация большого количества зависимых кэшей требует определенного времени.

\2. При инвалидации метки просто изменять версию этой метки.
Для реализации потребуется добавлять в кэш информацию о версиях меток.
При чтении кэша потребуются накладные расходы для сверки версии каждой его метки, и, если версия устарела, то кэш считается недействительным.
Достоинство этого подхода заключается в мгновенной инвалидации метки и всех ее зависимых кэшей.

Я выбрал второй вариант.


Многоуровневое кэширование и тегирование
========================================

Поскольку метки сверяются в момент чтения кэша, давайте представим, что произойдет, если один кэш поглощается другим кэшем.
Многоуровневый кэш - не редкость.
В таком случае, метки низлежащего, дочернего кэша никогда не пройдут сверку, и родительский кэш останется с неактуальными данными.
Необходимо явно передать метки родительскому кэшу в момент его создания, что может нарушать принцип инкапсуляции.

Поэтому система кэширования должна автоматически отслеживать связи между вложенными кэшами, и передавать метки от дочернего кэша к родительскому.


Проблема репликации
===================

При инвалидации кэша параллельный поток может успеть воссоздать кэш с устаревшими данными, прочитанными из slave в перид времени после инвалидации кэша, но до момента обновления slave.

Лучшим решением было бы блокирование создания кэша до момента обновления slave.
Но, во-первых, это сопряжено с определенными накладными расходами, а во-вторых, все потоки (в том числе и текущий) продолжают считывать устаревшие данные из slave (если не указано явное чтение из мастера).
Поэтому, компромиссным решением может быть просто повторная инвалидация кэша через период времени гарантированного обновления slave.

Под **блокировкой метки** имеется ввиду обход параллельными потоками процедуры сохранения кэша, помеченного этой меткой, а не блокирование параллельных потоков до освобождения метки.
Поскольку логика блокировки возложена на отдельный интерфейс, возможно реализовать любую другую логику блокировки, включая, `Pessimistic Offline Lock`_ или `Mutual Exclusion`_, как это сделано, например, в `wheezy.caching.patterns.OnePass <https://bitbucket.org/akorn/wheezy.caching/src/586b4debff62f885d97e646f0aa2e5d22d088bcf/src/wheezy/caching/patterns.py?at=default&fileviewer=file-view-default#patterns.py-348>`__).

Однако, ожидание параллельных потоков до момента обновления slave, который может иногда длиться 8 секунд и более, практически нереализуемо в веб-приложениях. Основных причин здесь две: рост количества ожидающих потоков может привести к перерасходу памяти и исчерпанию максимально допустимого числа коннектов к БД, а так же чрезмерное время ожидания клиентом ответа с сервера (клиент может попросту не дождаться ответа). Тем не менее, в некоторых (хотя и в редких) случаях, Мьютекс является единственно возможным вариантом.

В своей практике мне приходилось встречать использование регенерации кэша вместо его удаления/инвалидации.
Такой подход влечет за собой не совсем эффективное использование памяти кэша (работающего по LRU-принципу).
К тому же, он не решает проблему сложности инвалидации и по сути мало чем отличается от обычного удаления кэша, возлагая всю сложность на само приложение.
Так же он таит множество потенциальных баг.
Например, он чувствителен к качеству ORM, и если ORM не приводит все атрибуты инстанции модели к нужному типу при сохранении, то в кэш записываются неверные типы данных.
Мне приходилось видеть случай, когда атрибут даты записывался к кэш в формате строки, в таком же виде, в каком он пришел от клиента.
Хотя он и записывался в БД корректно, но модель не делала приведение типов без дополнительных манипуляций при сохранении (семантическое сопряжение).


Проблема транзакций
===================

Если Ваш проект имеет более-менее нормальную посещаемость, то с момента инвалидации кэша и до момента фиксации транзакции, параллельный поток может успеть воссоздать кэш с устаревшими данными.
В отличии от проблемы репликации, здесь проявление проблемы сильно зависит от качества ОРМ, и вероятность проблемы снижается при использовании паттерна `Unit of Work`_.

Рассмотрим проблему для каждого `уровня изоляции транзакции <Isolation_>`_ по отдельности.


Read uncommitted
----------------

Тут все просто, и никакой проблемы не может быть в принципе. В случае использования репликации достаточно сделать отложенный повтор инвалидации через интервал времени гарантированного обновления slave.


Read committed
--------------

Тут уже проблема может присутствовать, особенно если Вы используете `ActiveRecord`_.
Использование паттерна `DataMapper`_ в сочетании с `Unit of Work`_ заметно снижает интервал времени между сохранением данных и фиксацией транзакции, но вероятность проблемы все равно остается.

В отличии от проблемы репликации, здесь предпочтительней было бы блокирование создания кэша до момента фиксации транзакции, так как текущий поток видит в БД не те данные, которые видят параллельные потоки.
А поскольку нельзя гарантированно сказать какой именно поток, текущий или параллельный, создаст новый кэш, то создание кэша до фиксации транзакции было бы желательно избежать.

Тем не менее, этот уровень изоляции не является достаточно серьезным, и выбирается, как правило, для повышения степени параллелизма, т.е. с той же целью что и репликация.
А в таком случае, эта проблема обычно поглощается проблемой репликации, ведь чтение делается все равно из slave.

Поэтому, дорогостоящая блокировка может быть заменена просто повторной инвалидацией в момент фиксации транзакции.

Отдельно стоит упомянуть (спасибо `@akorn <https://bitbucket.org/akorn>`_) возможность `блокировки <https://www.postgresql.org/docs/9.5/static/explicit-locking.html>`__ строк в БД при использовании выражения `SELECT FOR UPDATE <https://www.postgresql.org/docs/9.5/static/sql-select.html#SQL-FOR-UPDATE-SHARE>`_. Но это будет работать только в том случае, если обе транзакции используют выражение `SELECT FOR UPDATE`_, в `противном случае <https://www.postgresql.org/docs/9.5/static/transaction-iso.html#XACT-READ-COMMITTED>`__:

    When a transaction uses this isolation level, a SELECT query (without a FOR UPDATE/SHARE clause) sees only data committed before the query began; it never sees either uncommitted data or changes committed during query execution by concurrent transactions. In effect, a SELECT query sees a snapshot of the database as of the instant the query begins to run.

Поскольку выборку для модификации никто не кеширует (да и вообще, в веб-приложениях ее мало кто использует), то она мало может быть нам полезна в этом вопросе. К тому же она не решает проблему репликации.


Repeatable reads
----------------

Этот случай наиболее интересен.
Здесь уже без блокировки создания кэша не обойтись, хотя бы потому, что нам нужно знать не только список меток, но и время фиксации всех транзакций, которые инвалидировали метки кэша.

Мало того, что мы должны заблокировать метку с момента инвалидации до момента фиксации транзакции, так мы еще и не можем создавать кэш в тех параллельных транзакциях, которые были открыты до момента фиксации текущей транзакции.

Хорошая новость заключается в том, что раз уж мы и вынуждены мириться с накладными расходами на блокировку меток, то можно блокировать их вплоть до обновления slave.


Serializable
------------

Поскольку несуществующие объекты обычно не кэшируются, то здесь достаточно ограничится той же проблематикой, что и для уровня `Repeatable reads`_.


Динамические окна в кэше
========================

Есть два взаимно-дополняющих паттерна, основанных на диаметрально противоположных принципах, - `Decorator`_ и `Strategy`_.
В первом случае изменяемая логика располагается вокруг объявленного кода, во втором - передается внутрь него.
Обычное кэширование имеет черты паттерна `Decorator`_, когда динамический код расположен вокруг закэшированной логики.
Но иногда в кэше небольшой фрагмент логики не должен подлежать кэшированию.
Например, персонализированные данные пользователя, проверка прав и т.п.

Один из вариантов решения этой проблемы - это использование технологии `Server Side Includes <https://en.wikipedia.org/wiki/Server_Side_Includes>`_.

Другой вариант - это использование двухфазной шаблонизации, например, используя библиотеку `django-phased <https://pypi.python.org/pypi/django-phased>`_.
Справедливости ради нужно отметить, что решение имеет немаленькое ресурсопотребление, и в некоторых случаях может нивелировать (если не усугублять) эффект от кэширования.
Возможно, именно поэтому, оно не получило широкого распространения.

Популярный шаблонный движок Smarty на PHP имеет функцию `{nocache} <http://www.smarty.net/docs/en/language.function.nocache.tpl>`_.

Но более интересной мне показалась возможность использовать в качестве динамического окна обычный Python-код, и абстрагироваться от сторонних технологий.


Заключение
==========

Надо признать, что я уделяю этой библиотеке мало внимания (а писалась она еще на заре моего освоения языка Python), и многое из того, что хотелось бы сделать, там не сделано.


.. _cache-tagging: https://bitbucket.org/emacsway/cache-tagging

.. _Decorator: https://en.wikipedia.org/wiki/Decorator_pattern
.. _Isolation: https://en.wikipedia.org/wiki/Isolation_(database_systems)
.. _Mutual Exclusion: https://en.wikipedia.org/wiki/Mutual_exclusion
.. _Observer: https://en.wikipedia.org/wiki/Observer_pattern
.. _Strategy: https://en.wikipedia.org/wiki/Strategy_pattern

.. _ActiveRecord: http://www.martinfowler.com/eaaCatalog/activeRecord.html
.. _DataMapper: http://martinfowler.com/eaaCatalog/dataMapper.html
.. _Pessimistic Offline Lock: http://martinfowler.com/eaaCatalog/pessimisticOfflineLock.html
.. _Unit of Work: http://martinfowler.com/eaaCatalog/unitOfWork.html
